# Task 3.1
def moderate_content(content):
    
    original_content = content
    score = 0
    
    TIER1_PATTERN = r'\b(' + '|'.join(TIER1_WORDS) + r')\b'
    if re.search(TIER1_PATTERN, original_content, flags=re.IGNORECASE):
        return "[content removed due to severe violation]", 5.0
   
    TIER2_PATTERN = r'(' + '|'.join(re.escape(phrase) for phrase in TIER2_PHRASES) + r')'
    if re.search(TIER2_PATTERN, original_content, flags=re.IGNORECASE):
        return "[content removed due to spam/scam policy]", 5.0
    
    TIER3_PATTERN = r'\b(' + '|'.join(TIER3_WORDS) + r')\b'
    matches = re.findall(TIER3_PATTERN, original_content, flags=re.IGNORECASE)
    score = len(matches) * 2
    moderated_content = re.sub(TIER3_PATTERN, lambda m: '*' * len(m.group(0)), original_content, flags=re.IGNORECASE)
    
    URL_PATTERN = r'(https?://\S+|www\.\S+)'
    urls = re.findall(URL_PATTERN, moderated_content)
    score += len(urls) * 2
    moderated_content = re.sub(URL_PATTERN, '[link removed]', moderated_content)

    letters_only = re.findall(r'[A-Za-z]', original_content)
    if len(letters_only) > 15:
        uppercase_count = sum(1 for ch in letters_only if ch.isupper())
        ratio = uppercase_count / len(letters_only)
        if ratio > 0.7:
            score += 0.5

    words = re.findall(r'\b\w+\b', content.lower())
    total_words = len(words)
    if total_words > 0:
        word_counts = Counter(words)
        most_common_word, freq = word_counts.most_common(1)[0]
        repetition_ratio = freq / total_words
        if freq >= 5 and repetition_ratio > 0.4:
            score += 1.0
    
    return moderated_content, score

def calculate_risk_score(user_id, content):
    
    moderated_text, base_score = moderate_content(content)

    user_data = query_db('SELECT joined FROM users WHERE user_id = ?', (user_id,), one=True)

    from datetime import datetime
    created_date = datetime.strptime(user_data['joined'], "%b %d, %Y %H:%M")
    today = datetime.now()
    account_age_days = (today - created_date).days

    if account_age_days < 7:
        risk_score = base_score * 1.5
    else:
        risk_score = base_score

    return moderated_text, risk_score


# Task 3.2
def user_risk_analysis(user_id):
    
    score = 0

    user_profile = query_db('SELECT profile_text, joined FROM users WHERE user_id = ?', (user_id,), one=True) 
    profile_text = user_profile.get('profile_text', '') or ''
    created_at = user_data.get('joined')
    _, profile_score = moderate_content(profile_text)

    user_posts = query_db('SELECT content FROM posts WHERE user_id = ?', (user_id,))
    post_scores = []
    for post in user_posts:
        _, post_risk_score = moderate_content(post['content'])
        post_scores.append(post_risk_score)
    average_post_score = sum(post_scores) / len(post_scores) if post_scores else 0
            
    user_comments = query_db('SELECT content FROM comments WHERE user_id = ?', (user_id,))
    comment_scores = []
    for comment in user_comments:
        _, comment_risk_score = moderate_content(comment['content'])
        comment_scores.append(comment_risk_score)
    average_comment_score = sum(comment_scores) / len(comment_scores) if comment_scores else 0

    content_risk_score = (profile_score * 1) + (average_post_score * 3) + (average_comment_score * 1)

    account_age_days = (datetime.now() - datetime.strptime(created_at, "%b %d, %Y %H:%M")).days

    if account_age_days < 7:
        user_risk_score = content_risk_score * 1.5
    elif account_age_days < 30:
        user_risk_score = content_risk_score * 1.2
    else:
        user_risk_score = content_risk_score

    user_risk_score = min(user_risk_score, 5.0)

    recent_posts = query_db('''
        SELECT COUNT(*) as count FROM posts
        WHERE user_id = ? AND created_at >= datetime('now', '-1 day')
    ''', (user_id,), one=True)
    if recent_posts and recent_posts['count'] > 10:
        user_risk_score = min(user_risk_score + 0.5, 5.0)

    return user_risk_score

def get_top_5_risky_users():
    users = query_db('SELECT DISTINCT user_id FROM posts UNION SELECT DISTINCT user_id FROM comments')
    
    user_scores = []
    for u in users:
        uid = u['user_id']
        risk_score = user_risk_analysis(uid)
        user_scores.append((uid, risk_score))

    top5.sort(user_scores, key=lambda x: x[1], reverse=True)
    return top5[:5]

# Task 3.3

def recommend(user_id):

    liked_posts = query_db('''
        SELECT p.content FROM posts p
        JOIN reactions r ON p.id = r.post_id
        WHERE r.user_id = ?
    ''', (user_id,))

    if not liked_posts:
        return query_db('''
            SELECT p.id, p.content, p.created_at, u.username, u.id AS user_id
            FROM posts p
            JOIN users u ON p.user_id = u.id
            WHERE p.user_id IN (SELECT followed_id FROM follows WHERE follower_id = ?)
               OR p.user_id != ?
            ORDER BY p.created_at DESC
            LIMIT 5
        ''', (user_id, user_id))

    word_counts = collections.Counter()
    stop_words = {'a', 'an', 'the', 'in', 'on', 'is', 'it', 'to', 'for', 'of', 'and', 'with'}

    for post in liked_posts:
        words = re.findall(r'\b\w+\b', post['content'].lower())
        for w in words:
            if w not in stop_words and len(w) > 2:
                word_counts[w] += 1

    top_keywords = [w for w, _ in word_counts.most_common(10)]

    all_posts = query_db('''
        SELECT p.id, p.content, p.created_at, u.username, u.id AS user_id
        FROM posts p
        JOIN users u ON p.user_id = u.id
        WHERE p.user_id != ?
    ''', (user_id,))

    followed_users = {
        f['followed_id'] for f in query_db('SELECT followed_id FROM follows WHERE follower_id = ?', (user_id,))
    }

    recommended = []
    for post in all_posts:
        text = post['content'].lower()

        keyword_hits = sum(1 for kw in top_keywords if kw in text)
        score = keyword_hits

        if post['user_id'] in followed_users:
            score += 1.0

        if score > 0:
            recommended.append((score, post))

    recommended.sort(key=lambda x: (x[0], x[1]['created_at']), reverse=True)
    top5 = [p for _, p in recommended]

    return top5[:5]
